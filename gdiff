diff --git a/Makefile b/Makefile
index 8571facaa..d45c4ed92 100644
--- a/Makefile
+++ b/Makefile
@@ -17,7 +17,8 @@ export PYTHON
 CLEAN_FILES = # deliberately empty, so we can append below.
 CFLAGS += ${EXTRA_CFLAGS}
 CXXFLAGS += ${EXTRA_CXXFLAGS}
-LDFLAGS += $(EXTRA_LDFLAGS)
+#LDFLAGS += $(EXTRA_LDFLAGS)
+LDFLAGS += -MMD -MP -MF -fPIE -Wl,--whole-archive -Wl,--no-as-needed -lzrocks -Wl,--no-whole-archive -Wl,--as-needed -luuid -fopenmp -laio $(EXTRA_LDFLAGS)
 MACHINE ?= $(shell uname -m)
 ARFLAGS = ${EXTRA_ARFLAGS} rs
 STRIPFLAGS = -S -x
@@ -449,9 +450,9 @@ ifeq ($(PLATFORM), OS_OPENBSD)
 	WARNING_FLAGS += -Wno-unused-lambda-capture
 endif
 
-ifndef DISABLE_WARNING_AS_ERROR
-	WARNING_FLAGS += -Werror
-endif
+#ifndef DISABLE_WARNING_AS_ERROR
+#	WARNING_FLAGS += -Werror
+#endif
 
 
 ifdef LUA_PATH
diff --git a/db/builder.cc b/db/builder.cc
index ad30be735..fce431143 100644
--- a/db/builder.cc
+++ b/db/builder.cc
@@ -138,7 +138,12 @@ Status BuildTable(
       bool use_direct_writes = file_options.use_direct_writes;
       TEST_SYNC_POINT_CALLBACK("BuildTable:create_file", &use_direct_writes);
 #endif  // !NDEBUG
-      IOStatus io_s = NewWritableFile(fs, fname, &file, file_options);
+      //IOStatus io_s = NewWritableFile(fs, fname, &file, file_options);
+      
+      IOStatus io_s = (env->writable_file_leveled) ?
+  	  NewWritableLeveledFile(env, fname, &file, file_options, level) :
+	    NewWritableFile(fs, fname, &file, file_options);
+
       assert(s.ok());
       s = io_s;
       if (io_status->ok()) {
diff --git a/db/compaction/compaction_job.cc b/db/compaction/compaction_job.cc
index 2dc6167d8..cd0565b36 100644
--- a/db/compaction/compaction_job.cc
+++ b/db/compaction/compaction_job.cc
@@ -1690,8 +1690,13 @@ Status CompactionJob::OpenCompactionOutputFile(
                            &syncpoint_arg);
 #endif
   Status s;
-  IOStatus io_s =
+  //IOStatus io_s = NewWritableFile(fs_.get(), fname, &writable_file, file_options_);
+
+  IOStatus io_s = (env_->writable_file_leveled) ?
+      NewWritableLeveledFile(env_, fname, &writable_file, file_options_,
+			     sub_compact->compaction->output_level()) :
       NewWritableFile(fs_.get(), fname, &writable_file, file_options_);
+
   s = io_s;
   if (sub_compact->io_status.ok()) {
     sub_compact->io_status = io_s;
diff --git a/env/env_zns.cc b/env/env_zns.cc
new file mode 100644
index 000000000..f9b14d516
--- /dev/null
+++ b/env/env_zns.cc
@@ -0,0 +1,761 @@
+//  Copyright (c) 2019, Samsung Electronics.  All rights reserved.
+//  This source code is licensed under both the GPLv2 (found in the
+//  COPYING file in the root directory) and Apache 2.0 License
+//  (found in the LICENSE.Apache file in the root directory).
+//
+//  Written by Ivan L. Picoli <i.picoli@samsung.com>
+
+#include <sys/time.h>
+#include <iostream>
+#include <memory>
+// #include "util/crc32c.h"
+#include "env/env_zns.h"
+#include "rocksdb/options.h"
+#include "rocksdb/slice.h"
+
+#define FILE_METADATA_BUF_SIZE (80 * 1024 * 1024)
+#define FLUSH_INTERVAL         (60 * 60)
+#define SLEEP_TIME             5
+#define MAX_META_ZONE          2
+#define MD_WRITE_FULL          0x1d
+
+enum Operation { Base, Update, Replace, Delete };
+
+namespace rocksdb {
+
+std::uint32_t ZNSFile::GetFileMetaLen() {
+  uint32_t metaLen = sizeof(ZrocksFileMeta);
+  metaLen += map.size() * sizeof(struct zrocks_map);
+  return metaLen;
+}
+
+std::uint32_t ZNSFile::WriteMetaToBuf(unsigned char* buf, bool update) {
+  // reserved single file head
+  std::uint32_t length = sizeof(ZrocksFileMeta);
+
+  ZrocksFileMeta fileMetaData;
+  fileMetaData.filesize = size;
+  fileMetaData.level    = level;
+  fileMetaData.pieceNum = map.size();
+  std::uint32_t i       = 0;
+  if (update) {
+    i                     = startIndex;
+    fileMetaData.pieceNum = map.size() - startIndex;
+  }
+
+  memcpy(fileMetaData.filename, name.c_str(), name.length());
+  memcpy(buf, &fileMetaData, sizeof(ZrocksFileMeta));
+  for (; i < map.size(); i++) {
+    memcpy(buf + length, &map[i], sizeof(struct zrocks_map));
+    length += sizeof(struct zrocks_map);
+  }
+
+  startIndex = map.size();
+
+  return length;
+}
+
+void ZNSFile::PrintMetaData() {
+  std::cout << __func__ << " FileName: " << name << " level: " << level
+            << " size: " << size << std::endl;
+  for (uint32_t i = 0; i < map.size(); i++) {
+    struct zrocks_map& pInfo = map[i];
+    std::cout << " nodeId: " << pInfo.g.node_id << " start: " << pInfo.g.start
+              << " num: " << pInfo.g.num << std::endl;
+  }
+}
+
+/* ### ZNS Environment method implementation ### 
+void ZNSEnv::NodeSta(std::int32_t znode_id, size_t n) {
+  double seconds;
+
+  if (start_ns == 0) {
+    GET_NANOSECONDS(start_ns, ts_s);
+  }
+
+  read_bytes[znode_id] += n;
+
+  GET_NANOSECONDS(end_ns, ts_e);
+  seconds      = (double)(end_ns - start_ns) / (double)1000000000;  // NOLINT
+  int totalcnt = 0, readcnt = 0;
+  if (seconds >= 2) {
+    for (int i = 0; i < ZNS_MAX_NODE_NUM; i++) {
+      if (alloc_flag[i]) {
+        totalcnt++;
+      }
+    }
+
+    for (int i = 0; i < ZNS_MAX_NODE_NUM; i++) {
+      if (read_bytes[i]) {
+        readcnt++;
+        read_bytes[i] = 0;
+      }
+    }
+
+    GET_NANOSECONDS(start_ns, ts_s);
+  }
+} */
+
+Status ZNSEnv::NewSequentialFile(const std::string&               fname,
+                                 std::unique_ptr<SequentialFile>* result,
+                                 const EnvOptions&                options) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << std::endl;
+
+  if (IsFilePosix(fname)) {
+    return posixEnv->NewSequentialFile(fname, result, options);
+  }
+
+  result->reset();
+
+  ZNSSequentialFile* f = new ZNSSequentialFile(fname, this, options);
+  result->reset(dynamic_cast<SequentialFile*>(f));
+
+  return Status::OK();
+}
+
+Status ZNSEnv::NewRandomAccessFile(const std::string&                 fname,
+                                   std::unique_ptr<RandomAccessFile>* result,
+                                   const EnvOptions&                  options) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << std::endl;
+
+  if (IsFilePosix(fname)) {
+    return posixEnv->NewRandomAccessFile(fname, result, options);
+  }
+
+  ZNSRandomAccessFile* f = new ZNSRandomAccessFile(fname, this, options);
+  result->reset(dynamic_cast<RandomAccessFile*>(f));
+
+  return Status::OK();
+}
+
+Status ZNSEnv::NewWritableFile(const std::string&             fname,
+                               std::unique_ptr<WritableFile>* result,
+                               const EnvOptions&              options) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << std::endl;
+
+  uint32_t fileNum = 0;
+
+  if (IsFilePosix(fname)) {
+    return posixEnv->NewWritableFile(fname, result, options);
+  } else {
+    posixEnv->NewWritableFile(fname, result, options);
+  }
+
+  filesMutex.Lock();
+  fileNum = files.count(fname);
+  filesMutex.Unlock();
+
+  if (fileNum != 0) {
+    delete files[fname];
+    files.erase(fname);
+  }
+
+  filesMutex.Lock();
+  files[fname]          = new ZNSFile(fname, 0);
+  files[fname]->uuididx = uuididx++;
+  filesMutex.Unlock();
+
+  ZNSWritableFile* f = new ZNSWritableFile(fname, this, options, 0);
+  result->reset(dynamic_cast<WritableFile*>(f));
+
+  return Status::OK();
+}
+
+Status ZNSEnv::NewWritableLeveledFile(const std::string&             fname,
+                                      std::unique_ptr<WritableFile>* result,
+                                      const EnvOptions& options, int level) {
+  level += 1;
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << " lvl: " << level << std::endl;
+
+  uint32_t fileNum = 0;
+
+  if (IsFilePosix(fname)) {
+    return posixEnv->NewWritableFile(fname, result, options);
+  } else {
+    posixEnv->NewWritableFile(fname, result, options);
+  }
+
+  if (level < 0) {
+    return NewWritableFile(fname, result, options);
+  }
+
+  filesMutex.Lock();
+  fileNum = files.count(fname);
+  filesMutex.Unlock();
+
+  if (fileNum != 0) {
+    delete files[fname];
+    files.erase(fname);
+  }
+
+  filesMutex.Lock();
+  files[fname]          = new ZNSFile(fname, level);
+  files[fname]->uuididx = uuididx++;
+  filesMutex.Unlock();
+
+  ZNSWritableFile* f = new ZNSWritableFile(fname, this, options, level);
+  result->reset(dynamic_cast<WritableFile*>(f));
+
+  return Status::OK();
+}
+
+Status ZNSEnv::DeleteFile(const std::string& fname) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << std::endl;
+
+  unsigned           i;
+  struct zrocks_map* map;
+
+  if (IsFilePosix(fname)) {
+    return posixEnv->DeleteFile(fname);
+  }
+  posixEnv->DeleteFile(fname);
+
+  filesMutex.Lock();
+  if (files.find(fname) == files.end() || files[fname] == NULL) {
+    filesMutex.Unlock();
+    return Status::OK();
+  }
+
+  ZNSFile* znsfile = files[fname];
+  for (i = 0; i < znsfile->map.size(); i++) {
+    map = &files[fname]->map.at(i);
+    zrocks_trim(map);
+  }
+
+  delete files[fname];
+  files.erase(fname);
+  filesMutex.Unlock();
+
+  FlushDelMetaData(fname);
+  return Status::OK();
+}
+
+Status ZNSEnv::GetFileSize(const std::string& fname, std::uint64_t* size) {
+  if (IsFilePosix(fname)) {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << fname << std::endl;
+    return posixEnv->GetFileSize(fname, size);
+  }
+
+  filesMutex.Lock();
+  if (files.find(fname) == files.end() || files[fname] == NULL) {
+    filesMutex.Unlock();
+    return Status::OK();
+  }
+
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << "size: " << files[fname]->size
+              << std::endl;
+
+  *size = files[fname]->size;
+  filesMutex.Unlock();
+
+  return Status::OK();
+}
+
+Status ZNSEnv::GetFileModificationTime(const std::string& fname,
+                                       std::uint64_t*     file_mtime) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << ":" << fname << std::endl;
+
+  if (IsFilePosix(fname)) {
+    return posixEnv->GetFileModificationTime(fname, file_mtime);
+  }
+
+  /* TODO: Get SST files modification time from ZNS */
+  *file_mtime = 0;
+
+  return Status::OK();
+}
+
+Status ZNSEnv::FlushMetaData() {
+  if (!ZNS_META_SWITCH) {
+    return Status::OK();
+  }
+
+  filesMutex.Lock();
+  memset(metaBuf, 0, FILE_METADATA_BUF_SIZE);
+  // reserved head position
+  std::uint32_t fileNum = 0;
+
+  MetaZoneHead mzHead;
+  mzHead.info.sequence = sequence++;
+  memcpy(metaBuf, &mzHead, sizeof(MetaZoneHead));
+  int dataLen = sizeof(MetaZoneHead) + sizeof(MetadataHead) + sizeof(fileNum);
+  if (ZNS_DEBUG_META)
+    std::cout << __func__ << " Start FlushMetaData " << std::endl;
+
+  std::map<std::string, ZNSFile*>::iterator itermap = files.begin();
+  for (; itermap != files.end(); ++itermap) {
+    ZNSFile* zfile = itermap->second;
+    if (zfile == NULL) {
+      continue;
+    }
+
+    fileNum++;
+    if (ZNS_DEBUG_META)
+      zfile->PrintMetaData();
+    if (dataLen + zfile->GetFileMetaLen() >= FILE_METADATA_BUF_SIZE) {
+      std::cout << __func__ << ": buf over flow" << std::endl;
+      filesMutex.Unlock();
+      return Status::MemoryLimit();
+    }
+
+    int length = zfile->WriteMetaToBuf(metaBuf + dataLen);
+    dataLen += length;
+  }
+  filesMutex.Unlock();
+
+  memcpy(metaBuf + sizeof(struct MetaZoneHead) + sizeof(MetadataHead), &fileNum,
+         sizeof(fileNum));
+
+  // sector align
+  if (dataLen % ZNS_ALIGMENT != 0) {
+    dataLen = (dataLen / ZNS_ALIGMENT + 1) * ZNS_ALIGMENT;
+  }
+
+  MetadataHead metadataHead;
+  metadataHead.dataLength = dataLen - sizeof(MetadataHead) - sizeof(MetaZoneHead);
+  metadataHead.tag        = Base;
+
+  /* std::uint32_t crc = 0;
+  crc               = crc32c::Extend(
+                    crc, (const char*)metaBuf + sizeof(SuperBlock) +
+  sizeof(MetadataHead), metadataHead.dataLength);
+  // std::cout << __func__ << ": crc " << crc << " crc32c::Mask(crc) " <<
+  // crc32c::Mask(crc) << " metadataHead.dataLength " << metadataHead.dataLength
+  // << std::endl;
+  crc              = crc32c::Mask(crc);
+  metadataHead.crc = crc; */
+
+  memcpy(metaBuf + sizeof(MetaZoneHead), &metadataHead, sizeof(MetadataHead));
+  int ret = zrocks_write_file_metadata(metaBuf, dataLen);
+  if (ret == MD_WRITE_FULL) {
+    std::cout << __func__ << ": zrocks_write_metadata Full " << ret << std::endl;
+    ret = zrocks_write_file_metadata(metaBuf, dataLen);
+  } else if (ret != 0) {
+     std::cout << __func__ << ": zrocks_write_metadata error " << ret << std::endl;
+  }
+
+  if (ZNS_DEBUG_META)
+    std::cout << __func__ << " End FlushMetaData " << std::endl;
+
+  return Status::OK();
+}
+
+Status ZNSEnv::FlushUpdateMetaData(ZNSFile* zfile) {
+  if (!ZNS_META_SWITCH) {
+    return Status::OK();
+  }
+
+  if (zfile->startIndex == zfile->map.size()) {
+    return Status::OK();
+  }
+  unsigned char* buf = NULL;
+  buf = reinterpret_cast<unsigned char*>(zrocks_alloc(ZNS_ALIGMENT));
+  if (buf == NULL) {
+    return Status::MemoryLimit();
+  }
+
+  memset(buf, 0, ZNS_ALIGMENT);
+
+  // reserved head position
+  int dataLen = sizeof(MetadataHead);
+  if (ZNS_DEBUG_META) {
+    std::cout << __func__ << " Start FlushUpdateMetaData " << zfile->name
+              << " level: " << zfile->level << " size: " << zfile->size
+              << std::endl;
+    for (std::uint32_t i = zfile->startIndex; i < zfile->map.size(); i++) {
+      struct zrocks_map& pInfo = zfile->map[i];
+      std::cout << " nodeId: " << pInfo.g.node_id << " start: " << pInfo.g.start
+                << " num: " << pInfo.g.num << std::endl;
+    }
+  }
+
+  int length = zfile->WriteMetaToBuf(buf + dataLen, true);
+  dataLen += length;
+
+  // sector align
+  if (dataLen % ZNS_ALIGMENT != 0) {
+    dataLen = (dataLen / ZNS_ALIGMENT + 1) * ZNS_ALIGMENT;
+  }
+
+  MetadataHead metadataHead;
+  metadataHead.tag        = Update;
+  metadataHead.dataLength = dataLen - sizeof(MetadataHead);
+
+  /* std::uint32_t crc = 0;
+  crc = crc32c::Extend(crc, (const char*)buf + sizeof(MetadataHead),
+                       metadataHead.dataLength);
+  crc = crc32c::Mask(crc);
+  metadataHead.crc = crc; */
+
+  memcpy(buf, &metadataHead, sizeof(MetadataHead));
+  metaMutex.Lock();
+  int ret = zrocks_write_file_metadata(buf, dataLen);
+  if (ret == MD_WRITE_FULL) {
+    std::cout << __func__ << ": zrocks_write_metadata FULL " << ret
+              << std::endl;
+    FlushMetaData();
+  } else if (ret != 0) {
+    std::cout << __func__ << ": zrocks_write_metadata error ret " << ret
+              << std::endl;
+  }
+  metaMutex.Unlock();
+
+  if (ZNS_DEBUG_META)
+    std::cout << __func__ << " End FlushUpdateMetaData " << std::endl;
+  zrocks_free(buf);
+
+  return Status::OK();
+}
+
+Status ZNSEnv::FlushDelMetaData(const std::string& fileName) {
+  if (!ZNS_META_SWITCH) {
+    return Status::OK();
+  }
+
+  unsigned char* buf = NULL;
+  buf = reinterpret_cast<unsigned char*>(zrocks_alloc(ZNS_ALIGMENT));
+  if (buf == NULL) {
+    return Status::MemoryLimit();
+  }
+
+  memset(buf, 0, ZNS_ALIGMENT);
+  // reserved head position
+  int dataLen = sizeof(MetadataHead);
+  if (ZNS_DEBUG_META)
+    std::cout << __func__ << " Start FlushDelMetaData fileName: " << fileName
+              << std::endl;
+
+  memcpy(buf + dataLen, fileName.c_str(), fileName.length());
+  dataLen += FILE_NAME_LEN;
+
+  // sector align
+  if (dataLen % ZNS_ALIGMENT != 0) {
+    dataLen = (dataLen / ZNS_ALIGMENT + 1) * ZNS_ALIGMENT;
+  }
+
+  MetadataHead metadataHead;
+  metadataHead.tag        = Delete;
+  metadataHead.dataLength = dataLen - sizeof(MetadataHead);
+
+  /* std::uint32_t crc = 0;
+  crc = crc32c::Extend(crc, (const char*)buf + sizeof(MetadataHead),
+                       metadataHead.dataLength);
+  crc = crc32c::Mask(crc);
+  metadataHead.crc = crc; */
+  memcpy(buf, &metadataHead, sizeof(MetadataHead));
+  metaMutex.Lock();
+  int ret = zrocks_write_file_metadata(buf, dataLen);
+  if (ret == MD_WRITE_FULL) {
+    std::cout << __func__ << ": zrocks_write_metadata FULL " << ret
+              << std::endl;
+    FlushMetaData();
+  } else if (ret != 0) {
+    std::cout << __func__ << ": zrocks_write_metadata error ret " << ret
+              << std::endl;
+  }
+  metaMutex.Unlock();
+
+  if (ZNS_DEBUG_META)
+    std::cout << __func__ << " End FlushDelMetaData " << std::endl;
+
+  zrocks_free(buf);
+  return Status::OK();
+}
+
+Status ZNSEnv::FlushReplaceMetaData(std::string& srcName,
+                                    std::string& destName) {
+  if (!ZNS_META_SWITCH) {
+    return Status::OK();
+  }
+
+  unsigned char* buf = NULL;
+  buf = reinterpret_cast<unsigned char*>(zrocks_alloc(ZNS_ALIGMENT));
+  if (buf == NULL) {
+    return Status::MemoryLimit();
+  }
+
+  memset(buf, 0, ZNS_ALIGMENT);
+  // reserved head position
+  int dataLen = sizeof(MetadataHead);
+  if (ZNS_DEBUG_META) {
+    std::cout << __func__ << " Start FlushReplaceMetaData srcName " << srcName
+              << " destName " << destName << std::endl;
+  }
+
+  memcpy(buf + dataLen, srcName.c_str(), srcName.length());
+  dataLen += FILE_NAME_LEN;
+
+  memcpy(buf + dataLen, destName.c_str(), destName.length());
+  dataLen += FILE_NAME_LEN;
+
+  // sector align
+  if (dataLen % ZNS_ALIGMENT != 0) {
+    dataLen = (dataLen / ZNS_ALIGMENT + 1) * ZNS_ALIGMENT;
+  }
+
+  MetadataHead metadataHead;
+  metadataHead.tag        = Replace;
+  metadataHead.dataLength = dataLen - sizeof(MetadataHead);
+
+  /* std::uint32_t crc = 0;
+  crc = crc32c::Extend(crc, (const char*)metaBuf + sizeof(MetadataHead),
+                       metadataHead.dataLength);
+  crc = crc32c::Mask(crc);
+  metadataHead.crc = crc; */
+
+  memcpy(buf, &metadataHead, sizeof(MetadataHead));
+  metaMutex.Lock();
+  int ret = zrocks_write_file_metadata(buf, dataLen);
+  if (ret == MD_WRITE_FULL) {
+    std::cout << __func__ << ": zrocks_write_metadata FULL " << ret
+              << std::endl;
+    FlushMetaData();
+  } else if (ret != 0) {
+    std::cout << __func__ << ": zrocks_write_metadata error ret " << ret
+              << std::endl;
+  }
+  metaMutex.Unlock();
+
+  if (ZNS_DEBUG_META)
+    std::cout << __func__ << " End FlushReplaceMetaData " << std::endl;
+  zrocks_free(buf);
+  return Status::OK();
+}
+
+void ZNSEnv::RecoverFileFromBuf(unsigned char* buf, std::uint32_t& praseLen) {
+  praseLen                    = 0;
+  ZrocksFileMeta fileMetaData = *(reinterpret_cast<ZrocksFileMeta*>(buf));
+  // std::cout << " filename: " << fileMetaData.filename <<std::endl;
+
+  ZNSFile* znsFile = files[fileMetaData.filename];
+  if (znsFile == NULL) {
+    znsFile = new ZNSFile(fileMetaData.filename, -1);
+  }
+
+  if (znsFile == NULL) {
+    return;
+  }
+
+  znsFile->size  = fileMetaData.filesize;
+  znsFile->level = fileMetaData.level;
+
+  std::uint32_t len = sizeof(ZrocksFileMeta);
+  for (std::uint16_t i = 0; i < fileMetaData.pieceNum; i++) {
+    struct zrocks_map p = *(reinterpret_cast<struct zrocks_map*>(buf + len));
+    znsFile->map.push_back(p);
+    // std::cout << " nodeId: " << p.g.node_id << " start: " << p.g.start <<  "
+    // num: " << p.g.num <<std::endl;
+    len += sizeof(struct zrocks_map);
+  }
+
+  if (ZNS_DEBUG_META) {
+    // znsFile->PrintMetaData();
+  }
+
+  filesMutex.Lock();
+  files[znsFile->name] = znsFile;
+  filesMutex.Unlock();
+
+  praseLen = len;
+}
+
+void ZNSEnv::ClearMetaData() {
+  std::map<std::string, ZNSFile*>::iterator iter;
+  for (iter = files.begin(); iter != files.end(); ++iter) {
+    delete iter->second;
+  }
+  files.clear();
+}
+
+void ZNSEnv::SetNodesInfo() {
+  std::map<std::string, ZNSFile*>::iterator iter;
+  for (iter = files.begin(); iter != files.end(); ++iter) {
+    ZNSFile* znsfile = iter->second;
+    for (uint32_t i = 0; i < znsfile->map.size(); i++) {
+      struct zrocks_map& pInfo = znsfile->map[i];
+      zrocks_node_set(pInfo.g.node_id, znsfile->level, pInfo.g.num);
+      // std::cout << " nodeId: " << pInfo.g.node_id << " level: " <<
+      // znsfile->level <<std::endl;
+    }
+  }
+}
+
+void ZNSEnv::PrintMetaData() {
+  std::map<std::string, ZNSFile*>::iterator iter;
+  for (iter = files.begin(); iter != files.end(); ++iter) {
+    ZNSFile* znsfile = iter->second;
+    if (znsfile != NULL) {
+        znsfile->PrintMetaData();
+    }
+  }
+}
+
+Status ZNSEnv::LoadMetaData() {
+  if (!ZNS_META_SWITCH) {
+    return Status::OK();
+  }
+
+  metaBuf =
+      reinterpret_cast<unsigned char*>(zrocks_alloc(FILE_METADATA_BUF_SIZE));
+  if (metaBuf == NULL) {
+    return Status::MemoryLimit();
+  }
+  memset(metaBuf, 0, FILE_METADATA_BUF_SIZE);
+
+  std::cout << __func__ << " Start LoadMetaData " << std::endl;
+
+  std::uint8_t  metaZoneNum              = MAX_META_ZONE;
+  std::uint64_t metaSlbas[MAX_META_ZONE] = {0};
+  zrocks_get_metadata_slbas(metaSlbas, &metaZoneNum);
+  int                                    ret = 0;
+  std::map<std::uint32_t, std::uint64_t> seqSlbaMap;
+  for (std::uint8_t i = 0; i < metaZoneNum; i++) {
+    ret = zrocks_read_metadata(metaSlbas[i], metaBuf, sizeof(MetaZoneHead));
+    if (ret) {
+      std::cout << "read superblock err" << std::endl;
+      return Status::IOError();
+    }
+
+    MetaZoneHead* mzHead = (MetaZoneHead*)metaBuf;
+    if (mzHead->info.magic == METADATA_MAGIC) {
+      seqSlbaMap[mzHead->info.sequence] = metaSlbas[i];
+      if (mzHead->info.sequence > sequence) {
+        sequence = mzHead->info.sequence;
+      }
+    }
+  }
+
+  std::map<std::uint32_t, std::uint64_t>::reverse_iterator iter;
+  for (iter = seqSlbaMap.rbegin(); iter != seqSlbaMap.rend(); ++iter) {
+    ClearMetaData();
+    std::uint64_t readSlba = iter->second + (sizeof(MetaZoneHead) / ZNS_ALIGMENT);
+    while (true) {
+      std::uint32_t readLen  = ZNS_ALIGMENT;
+      std::uint32_t praseLen = 0;
+      ret                    = zrocks_read_metadata(readSlba, metaBuf, readLen);
+      if (ret) {
+        std::cout << __func__ << ":  zrocks_read_metadata head error"
+                  << std::endl;
+        return Status::IOError();
+      }
+
+      MetadataHead* metadataHead = (MetadataHead*)metaBuf;
+      if (metadataHead->dataLength == 0) {
+        zrocks_switch_zone(iter->second);
+        sequence++;
+        goto LOAD_END;
+      }
+
+      if (metadataHead->dataLength + sizeof(MetadataHead) > readLen) {
+        ret = zrocks_read_metadata(
+            readSlba + readLen / ZNS_ALIGMENT, metaBuf + readLen,
+            metadataHead->dataLength + sizeof(MetadataHead) - readLen);
+        if (ret) {
+          std::cout << __func__ << ":  zrocks_read_metadata head error"
+                    << std::endl;
+          return Status::IOError();
+        }
+      }
+
+      /* uint32_t crc = 0;
+      crc = crc32c::Extend(crc, (const char*)metaBuf + sizeof(MetadataHead),
+                           metadataHead->dataLength);
+      // std::cout << __func__ << " crc " << crc << " metadataHead->crc " <<
+      // metadataHead->crc << " umask crc: " <<
+      // crc32c::Unmask(metadataHead->crc) << std::endl;
+      if (crc != crc32c::Unmask(metadataHead->crc)) {
+        std::cout << __func__ << ":  crc verify failed" << std::endl;
+        return Status::IOError();
+      } */
+
+      praseLen += sizeof(MetadataHead);
+      readSlba +=
+          (sizeof(MetadataHead) + metadataHead->dataLength) / ZNS_ALIGMENT;
+      switch (metadataHead->tag) {
+        case Base: {
+          std::uint32_t fileNum = *(std::uint32_t*)(metaBuf + praseLen);
+          praseLen += sizeof(fileNum);
+          for (std::uint16_t i = 0; i < fileNum; i++) {
+            std::uint32_t fileMetaLen = 0;
+            RecoverFileFromBuf(metaBuf + praseLen, fileMetaLen);
+            praseLen += fileMetaLen;
+          }
+          // printf("LOAD ALL\n");
+          // PrintMetaData();
+          // printf("LOAD ALL End\n");
+        } break;
+        case Update: {
+          std::uint32_t fileMetaLen = 0;
+          // printf("LOAD Update\n");
+          RecoverFileFromBuf(metaBuf + praseLen, fileMetaLen);
+          // printf("LOAD Update End\n");
+        } break;
+        case Replace: {
+          std::string srcFileName = (char*)metaBuf + praseLen;
+          praseLen += FILE_NAME_LEN;
+          std::string dstFileName = (char*)metaBuf + praseLen;
+          ZNSFile*    znsFile     = files[srcFileName];
+          files.erase(srcFileName);
+          files[dstFileName] = znsFile;
+        } break;
+        case Delete: {
+          std::string fileName = (char*)metaBuf + praseLen;
+          files.erase(fileName);
+          // printf("LOAD Delete\n");
+          // std::cout << "delete " << fileName << std::endl;
+          // printf("LOAD Delete End\n");
+        } break;
+        default:
+          break;
+      }
+    }
+  }
+
+LOAD_END:
+  SetNodesInfo();
+  if (ZNS_DEBUG_META) {
+    PrintMetaData();
+  }
+
+  zrocks_clear_invalid_nodes();
+
+  FlushMetaData();
+
+  std::cout << __func__ << " End LoadMetaData " << std::endl;
+  return Status::OK();
+}
+
+/* ### The factory method for creating a ZNS Env ### */
+Status NewZNSEnv(Env** zns_env, const std::string& dev_name) {
+  static ZNSEnv znsenv(dev_name);
+  ZNSEnv*       znsEnv = &znsenv;
+  *zns_env             = znsEnv;
+
+  znsEnv->envStartMutex.Lock();
+  if (znsEnv->isEnvStart) {
+    znsEnv->envStartMutex.Unlock();
+    return Status::OK();
+  }
+
+  // Load metaData
+  Status status = znsEnv->LoadMetaData();
+  if (!status.ok()) {
+    znsEnv->envStartMutex.Unlock();
+    std::cout << __func__ << ": znsEnv LoadMetaData error" << std::endl;
+    return Status::IOError();
+  }
+
+  znsEnv->envStartMutex.Unlock();
+
+  return Status::OK();
+}
+
+}  // namespace rocksdb
diff --git a/env/env_zns.h b/env/env_zns.h
new file mode 100644
index 000000000..e5a48d0e2
--- /dev/null
+++ b/env/env_zns.h
@@ -0,0 +1,631 @@
+//  Copyright (c) 2019, Samsung Electronics.  All rights reserved.
+//  This source code is licensed under both the GPLv2 (found in the
+//  COPYING file in the root directory) and Apache 2.0 License
+//  (found in the LICENSE.Apache file in the root directory).
+//
+//  Written by Ivan L. Picoli <i.picoli@samsung.com>
+
+#include <errno.h>
+#include <libzrocks.h>
+#include <pthread.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <atomic>
+#include <iostream>
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "port/port.h"
+#include "rocksdb/env.h"
+#include "rocksdb/statistics.h"
+
+#define ZNS_DEBUG       1
+#define ZNS_DEBUG_R     (ZNS_DEBUG && 1) /* Read */
+#define ZNS_DEBUG_W     (ZNS_DEBUG && 1) /* Write and Sync */
+#define ZNS_DEBUG_AF    (ZNS_DEBUG && 1) /* Append and Flush */
+#define ZNS_DEBUG_META  0                /* MetaData Flush and Recover */
+#define ZNS_META_SWITCH 1                /* MetaData Switch 0:Close   1:Open */
+
+#define ZNS_OBJ_STORE       0
+#define ZNS_PREFETCH        0
+#define ZNS_PREFETCH_BUF_SZ (1024 * 1024 * 1) /* 1MB */
+#define ZROCKS_MAX_READ_SZ  (1024 * ZNS_ALIGMENT)
+
+#define ZNS_MAX_MAP_ENTS 64
+#define ZNS_MAX_NODE_NUM 6000
+
+#define METADATA_MAGIC      0x3D
+#define FILE_METADATA_MAGIC 0x3E
+#define FILE_NAME_LEN       128
+
+#define ZNS_FILE_TAIL_BUF (2 * 1024 * 1024)
+#define GET_NANOSECONDS(ns, ts)                       \
+  do {                                                \
+    clock_gettime(CLOCK_REALTIME, &ts);               \
+    (ns) = ((ts).tv_sec * 1000000000 + (ts).tv_nsec); \
+  } while (0)
+
+namespace rocksdb {
+
+/* ### ZNS Environment ### */
+struct MetaZoneHead {
+  union {
+    struct {
+      std::uint8_t  magic;
+      std::uint32_t sequence;
+    } info;
+    char addr[ZNS_ALIGMENT];
+  };
+  MetaZoneHead() {
+    info.magic    = METADATA_MAGIC;
+    info.sequence = 0;
+  }
+};
+
+struct MetadataHead {
+  std::uint32_t crc;
+  std::uint32_t dataLength;
+  std::uint8_t  tag;
+  MetadataHead() {
+    crc        = 0;
+    dataLength = 0;
+    tag        = 0;
+  }
+};
+
+struct ZrocksFileMeta {
+  int8_t        level;
+  std::uint64_t filesize;
+  std::int32_t  pieceNum;
+  char          filename[FILE_NAME_LEN];
+
+  ZrocksFileMeta() {
+    level    = -1;
+    filesize = 0;
+    pieceNum = 0;
+    memset(filename, 0, sizeof(filename));
+  }
+};
+
+struct ZrocksMediaRes {
+  int rid;
+  int cnt;
+};
+
+class ZNSFile {
+ public:
+  const std::string              name;
+  size_t                         size;
+  size_t                         before_truncate_size;
+  std::uint64_t                  uuididx;
+  int                            level;
+  std::vector<struct zrocks_map> map;
+  std::uint32_t                  startIndex;
+
+  char* wcache;
+  char* cache_off;
+  ZNSFile(const std::string& fname, int lvl)
+      : name(fname), uuididx(0), level(lvl) {
+    before_truncate_size = 0;
+    size                 = 0;
+    startIndex           = 0;
+    wcache = reinterpret_cast<char*>(zrocks_alloc(ZNS_MAX_BUF));
+    if (!wcache) {
+      std::cout << " ZRocks (alloc) error." << std::endl;
+      cache_off = nullptr;
+    }
+    cache_off = wcache;
+  }
+
+  ~ZNSFile() {
+    if (wcache) {
+      zrocks_free(wcache);
+      wcache = NULL;
+      cache_off = NULL;
+    }
+  }
+
+  std::uint32_t GetFileMetaLen();
+
+  std::uint32_t WriteMetaToBuf(unsigned char* buf, bool update = false);
+
+  void PrintMetaData();
+};
+
+class ZNSEnv : public Env {
+ public:
+  port::Mutex                     filesMutex;
+  std::map<std::string, ZNSFile*> files;
+  uint64_t                        sequence;
+  uint64_t                        read_bytes[ZNS_MAX_NODE_NUM];
+  bool                            alloc_flag[ZNS_MAX_NODE_NUM];
+
+  port::Mutex   envStartMutex;
+  bool          isEnvStart;
+  std::uint64_t uuididx;
+  port::Mutex   metaMutex;
+
+  unsigned char* metaBuf;
+  explicit ZNSEnv(const std::string& dname) : dev_name(dname) {
+    posixEnv              = Env::Default();
+    writable_file_leveled = true;
+    isFlushRuning         = false;
+    isEnvStart            = false;
+    uuididx               = 0;
+    flushThread           = 0;
+    sequence              = 0;
+    metaBuf               = NULL;
+    std::cout << "Initializing ZNS Environment" << std::endl;
+
+    if (zrocks_init(dev_name.data())) {
+      std::cout << "ZRocks failed to initialize." << std::endl;
+      exit(1);
+    }
+
+    for (int i = 0; i < ZNS_MAX_NODE_NUM; i++) {
+      read_bytes[i] = 0;
+      alloc_flag[i] = false;
+    }
+  }
+
+  virtual ~ZNSEnv() {
+    if (ZNS_META_SWITCH) {
+       zrocks_free(metaBuf);
+    }
+    // FlushMetaData();
+    PrintMetaData();
+    zrocks_exit();
+    std::cout << "Destroying ZNS Environment" << std::endl;
+  }
+
+  Status FlushMetaData();
+
+  Status FlushUpdateMetaData(ZNSFile* zfile);
+
+  Status FlushDelMetaData(const std::string& fileName);
+
+  Status FlushReplaceMetaData(std::string& srcName, std::string& destName);
+
+  void RecoverFileFromBuf(unsigned char* buf, std::uint32_t& praseLen);
+
+  Status LoadMetaData();
+
+  void ClearMetaData();
+
+  void PrintMetaData();
+
+  void SetNodesInfo();
+
+  /* ### Implemented at env_zns.cc ### */
+
+  // void NodeSta(std::int32_t znode_id, size_t n);
+
+  Status NewSequentialFile(const std::string&               fname,
+                           std::unique_ptr<SequentialFile>* result,
+                           const EnvOptions&                options) override;
+
+  Status NewRandomAccessFile(const std::string&                 fname,
+                             std::unique_ptr<RandomAccessFile>* result,
+                             const EnvOptions& options) override;
+
+  Status NewWritableFile(const std::string&             fname,
+                         std::unique_ptr<WritableFile>* result,
+                         const EnvOptions&              options) override;
+
+  Status NewWritableLeveledFile(const std::string&             fname,
+                                std::unique_ptr<WritableFile>* result,
+                                const EnvOptions& options, int level) override;
+
+  Status DeleteFile(const std::string& fname) override;
+
+  Status GetFileSize(const std::string& fname, std::uint64_t* size) override;
+
+  Status GetFileModificationTime(const std::string& fname,
+                                 std::uint64_t*     file_mtime) override;
+
+  /* ### Implemented here ### */
+
+  Status LinkFile(const std::string& /*src*/,
+                  const std::string& /*target*/) override {
+    return Status::NotSupported();  // not supported
+  }
+
+  static std::uint64_t gettid() {
+    assert(sizeof(pthread_t) <= sizeof(std::uint64_t));
+    return (std::uint64_t)pthread_self();
+  }
+
+  std::uint64_t GetThreadID() const override {
+    return ZNSEnv::gettid();
+  }
+
+  /* ### Posix inherited functions ### */
+
+  Status NewDirectory(const std::string&          name,
+                      std::unique_ptr<Directory>* result) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << name << std::endl;
+    return posixEnv->NewDirectory(name, result);
+  }
+
+  Status FileExists(const std::string& fname) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << fname << std::endl;
+    return posixEnv->FileExists(fname);
+  }
+
+  Status GetChildren(const std::string&        path,
+                     std::vector<std::string>* result) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << path << std::endl;
+    return posixEnv->GetChildren(path, result);
+  }
+
+  Status CreateDir(const std::string& name) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << name << std::endl;
+    return posixEnv->CreateDir(name);
+  }
+
+  Status CreateDirIfMissing(const std::string& name) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << name << std::endl;
+    return posixEnv->CreateDirIfMissing(name);
+  }
+
+  Status DeleteDir(const std::string& name) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << name << std::endl;
+    return posixEnv->DeleteDir(name);
+  }
+
+  Status RenameFile(const std::string& src,
+                    const std::string& target) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << src << ":" << target << std::endl;
+    return posixEnv->RenameFile(src, target);
+  };
+
+  Status LockFile(const std::string& fname, FileLock** lock) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << fname << std::endl;
+    return posixEnv->LockFile(fname, lock);
+  }
+
+  Status UnlockFile(FileLock* lock) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << std::endl;
+    return posixEnv->UnlockFile(lock);
+  }
+
+  Status IsDirectory(const std::string& path, bool* is_dir) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << path << std::endl;
+    return posixEnv->IsDirectory(path, is_dir);
+  }
+
+  Status NewLogger(const std::string&       fname,
+                   std::shared_ptr<Logger>* result) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << ":" << fname << std::endl;
+    return posixEnv->NewLogger(fname, result);
+  }
+
+  void Schedule(void (*function)(void* arg), void* arg, Priority pri = LOW,
+                void* tag                          = nullptr,
+                void (*unschedFunction)(void* arg) = 0) override {
+    posixEnv->Schedule(function, arg, pri, tag, unschedFunction);
+  }
+
+  int UnSchedule(void* tag, Priority pri) override {
+    return posixEnv->UnSchedule(tag, pri);
+  }
+
+  void StartThread(void (*function)(void* arg), void* arg) override {
+    posixEnv->StartThread(function, arg);
+  }
+
+  void WaitForJoin() override {
+    posixEnv->WaitForJoin();
+  }
+
+  unsigned int GetThreadPoolQueueLen(Priority pri = LOW) const override {
+    return posixEnv->GetThreadPoolQueueLen(pri);
+  }
+
+  Status GetTestDirectory(std::string* path) override {
+    return posixEnv->GetTestDirectory(path);
+  }
+
+  std::uint64_t NowMicros() override {
+    return posixEnv->NowMicros();
+  }
+
+  void SleepForMicroseconds(int micros) override {
+    posixEnv->SleepForMicroseconds(micros);
+  }
+
+  Status GetHostName(char* name, std::uint64_t len) override {
+    return posixEnv->GetHostName(name, len);
+  }
+
+  Status GetCurrentTime(int64_t* unix_time) override {
+    return posixEnv->GetCurrentTime(unix_time);
+  }
+
+  Status GetAbsolutePath(const std::string& db_path,
+                         std::string*       output_path) override {
+    return posixEnv->GetAbsolutePath(db_path, output_path);
+  }
+
+  void SetBackgroundThreads(int number, Priority pri = LOW) override {
+    posixEnv->SetBackgroundThreads(number, pri);
+  }
+
+  int GetBackgroundThreads(Priority pri = LOW) override {
+    return posixEnv->GetBackgroundThreads(pri);
+  }
+
+  void IncBackgroundThreadsIfNeeded(int number, Priority pri) override {
+    posixEnv->IncBackgroundThreadsIfNeeded(number, pri);
+  }
+
+  std::string TimeToString(std::uint64_t number) override {
+    return posixEnv->TimeToString(number);
+  }
+
+  Status GetThreadList(std::vector<ThreadStatus>* thread_list) {
+    return posixEnv->GetThreadList(thread_list);
+  }
+
+  ThreadStatusUpdater* GetThreadStatusUpdater() const override {
+    return posixEnv->GetThreadStatusUpdater();
+  }
+
+ private:
+  Env* posixEnv;  // This object is derived from Env, but not from
+                  // posixEnv. We have posixnv as an encapsulated
+                  // object here so that we can use posix timers,
+                  // posix threads, etc.
+  const std::string dev_name;
+  pthread_t         flushThread;
+  bool              isFlushRuning;
+  bool              IsFilePosix(const std::string& fname) {
+    return (fname.find("uuid") != std::string::npos ||
+            fname.find("CURRENT") != std::string::npos ||
+            fname.find("IDENTITY") != std::string::npos ||
+            fname.find("MANIFEST") != std::string::npos ||
+            fname.find("OPTIONS") != std::string::npos ||
+            fname.find("LOG") != std::string::npos ||
+            fname.find("LOCK") != std::string::npos ||
+            fname.find(".dbtmp") != std::string::npos ||
+            // fname.find(".log") != std::string::npos ||
+            fname.find(".trace") != std::string::npos);
+  }
+};
+
+/* ### SequentialFile, RandAccessFile, and Writable File ### */
+
+class ZNSSequentialFile : public SequentialFile {
+ private:
+  std::string   filename_;
+  bool          use_direct_io_;
+  size_t        logical_sector_size_;
+  std::uint64_t ztl_id;
+  ZNSFile*      znsfile;
+  ZNSEnv*       env_zns;
+  uint64_t      read_off;
+
+ public:
+  ZNSSequentialFile(const std::string& fname, ZNSEnv* zns,
+                    const EnvOptions& options)
+      : filename_(fname),
+        use_direct_io_(options.use_direct_reads),
+        logical_sector_size_(ZNS_ALIGMENT) {
+    env_zns  = zns;
+    read_off = 0;
+    znsfile  = env_zns->files[fname];
+    ztl_id = 0;
+  }
+
+  virtual ~ZNSSequentialFile() {
+  }
+
+  /* ### Implemented at env_zns_io.cc ### */
+
+  Status ReadOffset(uint64_t offset, size_t n, Slice* result, char* scratch,
+                    size_t* readLen) const;
+
+  Status Read(size_t n, Slice* result, char* scratch) override;
+
+  Status PositionedRead(std::uint64_t offset, size_t n, Slice* result,
+                        char* scratch) override;
+
+  Status Skip(std::uint64_t n) override;
+
+  Status InvalidateCache(size_t offset, size_t length) override;
+
+  /* ### Implemented here ### */
+
+  bool use_direct_io() const override {
+    return use_direct_io_;
+  }
+
+  size_t GetRequiredBufferAlignment() const override {
+    return logical_sector_size_;
+  }
+};
+
+class ZNSRandomAccessFile : public RandomAccessFile {
+ private:
+  std::string   filename_;
+  bool          use_direct_io_;
+  size_t        logical_sector_size_;
+  std::uint64_t uuididx;
+
+  ZNSEnv*  env_zns;
+  ZNSFile* znsfile;
+
+#if ZNS_PREFETCH
+  char*            prefetch;
+  size_t           prefetch_sz;
+  std::uint64_t    prefetch_off;
+  std::atomic_flag prefetch_lock = ATOMIC_FLAG_INIT;
+#endif
+
+ public:
+  ZNSRandomAccessFile(const std::string& fname, ZNSEnv* zns,
+                      const EnvOptions& options)
+      : filename_(fname),
+        use_direct_io_(options.use_direct_reads),
+        logical_sector_size_(ZNS_ALIGMENT),
+        uuididx(0),
+        env_zns(zns) {
+#if ZNS_PREFETCH
+    prefetch_off = 0;
+#endif
+    env_zns->filesMutex.Lock();
+    znsfile = env_zns->files[filename_];
+    env_zns->filesMutex.Unlock();
+
+#if ZNS_PREFETCH
+    prefetch = reinterpret_cast<char*>(zrocks_alloc(ZNS_PREFETCH_BUF_SZ));
+    if (!prefetch) {
+      std::cout << " ZRocks (alloc prefetch) error." << std::endl;
+      prefetch = nullptr;
+    }
+    prefetch_sz = 0;
+#endif
+  }
+
+  virtual ~ZNSRandomAccessFile() {
+#if ZNS_PREFETCH
+    zrocks_free(prefetch);
+#endif
+  }
+
+  /* ### Implemented at env_zns_io.cc ### */
+
+  Status Read(std::uint64_t offset, size_t n, Slice* result,
+              char* scratch) const override;
+
+  Status Prefetch(std::uint64_t offset, size_t n) override;
+
+  size_t GetUniqueId(char* id, size_t max_size) const override;
+
+  Status InvalidateCache(size_t offset, size_t length) override;
+
+  virtual Status ReadObj(std::uint64_t offset, size_t n, Slice* result,
+                         char* scratch) const;
+
+  virtual Status ReadOffset(std::uint64_t offset, size_t n, Slice* result,
+                            char* scratch) const;
+
+  /* ### Implemented here ### */
+
+  bool use_direct_io() const override {
+    return use_direct_io_;
+  }
+
+  size_t GetRequiredBufferAlignment() const override {
+    return logical_sector_size_;
+  }
+};
+
+class ZNSWritableFile : public WritableFile {
+ private:
+  const std::string filename_;
+  const bool        use_direct_io_;
+  int               fd_;
+  std::uint64_t     filesize_;
+  ZNSFile*          znsfile;
+  size_t            logical_sector_size_;
+#ifdef ROCKSDB_FALLOCATE_PRESENT
+  bool allow_fallocate_;
+  bool fallocate_with_keep_size_;
+#endif
+
+  int   level;
+
+  ZNSEnv*       env_zns;
+  std::uint64_t map_off;
+
+ public:
+  explicit ZNSWritableFile(const std::string& fname, ZNSEnv* zns,
+                           const EnvOptions& options, int lvl)
+      : WritableFile(options),
+        filename_(fname),
+        use_direct_io_(options.use_direct_writes),
+        fd_(0),
+        filesize_(0),
+        logical_sector_size_(ZNS_ALIGMENT),
+        level(lvl),
+        env_zns(zns) {
+#ifdef ROCKSDB_FALLOCATE_PRESENT
+    allow_fallocate_          = options.allow_fallocate;
+    fallocate_with_keep_size_ = options.fallocate_with_keep_size;
+#endif
+
+    map_off   = 0;
+
+    zns->filesMutex.Lock();
+    znsfile = env_zns->files[fname];
+    zns->filesMutex.Unlock();
+  }
+
+  virtual ~ZNSWritableFile() {
+  }
+
+  /* ### Implemented at env_zns_io.cc ### */
+
+  Status Append(const Slice& data) override;
+
+  Status PositionedAppend(const Slice& data, std::uint64_t offset) override;
+  Status Append(const rocksdb::Slice&, const rocksdb::DataVerificationInfo&);
+  Status PositionedAppend(const rocksdb::Slice&, uint64_t,
+                          const rocksdb::DataVerificationInfo&);
+
+  Status Truncate(std::uint64_t size) override;
+
+  Status Close() override;
+
+  Status Flush() override;
+
+  Status Sync() override;
+
+  Status Fsync() override;
+
+  Status InvalidateCache(size_t offset, size_t length) override;
+
+#ifdef ROCKSDB_FALLOCATE_PRESENT
+  Status Allocate(std::uint64_t offset, std::uint64_t len) override;
+#endif
+
+  Status RangeSync(std::uint64_t offset, std::uint64_t nbytes) override;
+
+  size_t GetUniqueId(char* id, size_t max_size) const override;
+
+  /* ### Implemented here ### */
+
+  bool IsSyncThreadSafe() const override {
+    return true;
+  }
+
+  bool use_direct_io() const override {
+    return use_direct_io_;
+  }
+
+  void SetWriteLifeTimeHint(Env::WriteLifeTimeHint hint) override {
+    if (ZNS_DEBUG)
+      std::cout << __func__ << " : " << hint << std::endl;
+  }
+
+  size_t GetRequiredBufferAlignment() const override {
+    return logical_sector_size_;
+  }
+};
+
+}  // namespace rocksdb
diff --git a/env/env_zns_io.cc b/env/env_zns_io.cc
new file mode 100644
index 000000000..ef4b1f15b
--- /dev/null
+++ b/env/env_zns_io.cc
@@ -0,0 +1,593 @@
+//  Copyright (c) 2019, Samsung Electronics.  All rights reserved.
+//  This source code is licensed under both the GPLv2 (found in the
+//  COPYING file in the root directory) and Apache 2.0 License
+//  (found in the LICENSE.Apache file in the root directory).
+//
+//  Written by Ivan L. Picoli <i.picoli@samsung.com>
+
+#include <string.h>
+#include <sys/time.h>
+#include <util/coding.h>
+
+#include <atomic>
+#include <iostream>
+
+#include "env/env_zns.h"
+#include "rocksdb/options.h"
+#include "rocksdb/slice.h"
+
+namespace rocksdb {
+
+/* ### SequentialFile method implementation ### */
+
+Status ZNSSequentialFile::ReadOffset(uint64_t offset, size_t n, Slice* result,
+                                     char* scratch, size_t* readLen) const {
+  struct zrocks_map* map;
+  size_t             piece_off = 0, left, size;
+  int                ret;
+  unsigned           i;
+  uint64_t           off;
+
+  if (znsfile == NULL || offset >= znsfile->size) {
+    return Status::OK();
+  }
+
+  if (ZNS_DEBUG_R)
+    std::cout << __func__ << " name: " << filename_ << " offset: " << offset
+              << " size: " << n << " file_size:  " << znsfile->size
+              << std::endl;
+
+  if (offset + n > znsfile->size) {
+    n = znsfile->size - offset;
+  }
+
+  size_t cache_len = znsfile->cache_off - znsfile->wcache;
+  size_t cache_pos = znsfile->size - cache_len;
+  if (offset >= cache_pos) {
+    *result = Slice(znsfile->wcache + offset - cache_pos, n);
+    return Status::OK();
+  }
+  // env_zns->filesMutex.Lock();
+  std::vector<struct zrocks_map> temlist;
+  temlist.assign(znsfile->map.begin(), znsfile->map.end());
+  // env_zns->filesMutex.Unlock();
+
+  off = 0;
+  for (i = 0; i < temlist.size(); i++) {
+    map  = &temlist.at(i);
+    size = map->g.num * ZNS_ALIGMENT * ZTL_IO_SEC_MCMD;
+    if (off + size > offset) {
+      piece_off = size - (off + size - offset);
+      break;
+    }
+    off += size;
+  }
+
+  if (i == temlist.size()) {
+    if (ZNS_DEBUG_R)
+      std::cout << __func__ << " name: " << filename_ << " error: No fit map! "
+                << std::endl;
+    return Status::IOError();
+  }
+
+  /* Create one read per piece */
+  left = n;
+  while (left) {
+    map          = &temlist.at(i);
+    size         = map->g.num * ZNS_ALIGMENT * ZTL_IO_SEC_MCMD;
+    size         = (size - piece_off > left) ? left : size - piece_off;
+    uint64_t tmp = map->g.start;
+    off          = tmp * ZNS_ALIGMENT * ZTL_IO_SEC_MCMD;
+
+    if (ZNS_DEBUG_R)
+      std::cout << __func__ << " name: " << filename_ << " map: " << i
+                << " node: " << map->g.node_id << " start: " << map->g.start
+                << " num: " << map->g.num << " left " << left << std::endl;
+
+    off += piece_off;
+    ret = zrocks_read(map->g.node_id, off, scratch + (n - left), size);
+    if (ret) {
+      return Status::IOError();
+    }
+
+    left -= size;
+    piece_off = 0;
+    i++;
+  }
+
+  *readLen = n;
+  *result  = Slice(scratch, n);
+  return Status::OK();
+}
+
+Status ZNSSequentialFile::Read(size_t n, Slice* result, char* scratch) {
+  size_t readLen = 0;
+  Status status  = ReadOffset(read_off, n, result, scratch, &readLen);
+
+  if (status.ok())
+    read_off += readLen;
+
+  return status;
+}
+
+Status ZNSSequentialFile::PositionedRead(uint64_t offset, size_t n,
+                                         Slice* result, char* scratch) {
+  if (ZNS_DEBUG)
+    std::cout << "WARNING: " << __func__ << " offset: " << offset << " n: " << n
+              << std::endl;
+  size_t readLen = 0;
+  Status status  = ReadOffset(read_off, n, result, scratch, &readLen);
+
+  *result = Slice(scratch, readLen);
+
+  return Status::OK();
+}
+
+Status ZNSSequentialFile::Skip(uint64_t n) {
+  if (ZNS_DEBUG)
+    std::cout << "WARNING: " << __func__ << " n: " << n << std::endl;
+  if (read_off + n <= znsfile->size) {
+    read_off += n;
+  }
+  return Status::OK();
+}
+
+Status ZNSSequentialFile::InvalidateCache(size_t offset, size_t length) {
+  if (ZNS_DEBUG) {
+    std::cout << __func__ << " offset: " << offset << " length: " << length
+              << std::endl;
+  }
+  return Status::OK();
+}
+
+/* ### RandomAccessFile method implementation ### */
+
+Status ZNSRandomAccessFile::ReadObj(uint64_t offset, size_t n, Slice* result,
+                                    char* scratch) const {
+  int ret = 0;
+
+  if (ZNS_DEBUG_R) {
+    std::cout << __func__ << "name: " << filename_ << " offset: " << offset
+              << " size: " << n << std::endl;
+  }
+
+  ret = zrocks_read_obj(0, offset, scratch, n);
+  if (ret) {
+    std::cout << " ZRocks (read_obj) error: " << ret << std::endl;
+    return Status::IOError();
+  }
+
+  *result = Slice(scratch, n);
+
+  return Status::OK();
+}
+
+Status ZNSRandomAccessFile::ReadOffset(uint64_t offset, size_t n, Slice* result,
+                                       char* scratch) const {
+  struct zrocks_map* map;
+  size_t             piece_off = 0, left, msize;
+  int                ret;
+  unsigned           i;
+  uint64_t           off;
+
+  if (ZNS_DEBUG_R)
+    std::cout << __func__ << " name: " << filename_ << " offset: " << offset
+              << " size: " << n << " file_size:  " << znsfile->size
+              << std::endl;
+
+  // env_zns->filesMutex.Lock();
+  std::vector<struct zrocks_map> temlist;
+  temlist.assign(znsfile->map.begin(), znsfile->map.end());
+  // env_zns->filesMutex.Unlock();
+
+  off = 0;
+  for (i = 0; i < temlist.size(); i++) {
+    map   = &temlist.at(i);
+    msize = map->g.num * ZNS_ALIGMENT * ZTL_IO_SEC_MCMD;
+    if (off + msize > offset) {
+      piece_off = msize - (off + msize - offset);
+      break;
+    }
+    off += msize;
+  }
+
+  if (i == temlist.size()) {
+    if (ZNS_DEBUG_R) {
+      std::cout << __func__ << " name: " << filename_ << " error: No fit map! "
+                << std::endl;
+    }
+
+    return Status::IOError();
+  }
+
+  /* Create one read per piece */
+  left = n;
+  while (left) {
+    map          = &temlist.at(i);
+    msize        = map->g.num * ZNS_ALIGMENT * ZTL_IO_SEC_MCMD;
+    msize        = (msize - piece_off > left) ? left : msize - piece_off;
+    uint64_t tmp = map->g.start;  // bug-fix
+    off          = tmp * ZNS_ALIGMENT * ZTL_IO_SEC_MCMD;
+
+    if (ZNS_DEBUG_R)
+      std::cout << __func__ << " name: " << filename_ << " map: " << i
+                << " node: " << map->g.node_id << " start: " << map->g.start
+                << " num: " << map->g.num << " piece_off: " << piece_off
+                << " left " << left << " readoff: " << off
+                << " readsize: " << msize << std::endl;
+
+    off += piece_off;
+    ret = zrocks_read(map->g.node_id, off, scratch + (n - left), msize);
+    if (ret) {
+      return Status::IOError();
+    }
+
+    left -= msize;
+    piece_off = 0;
+    i++;
+  }
+
+  *result = Slice(scratch, n);
+  return Status::OK();
+}
+
+Status ZNSRandomAccessFile::Read(uint64_t offset, size_t n, Slice* result,
+                                 char* scratch) const {
+#if ZNS_PREFETCH
+  std::atomic_flag* flag = const_cast<std::atomic_flag*>(&prefetch_lock);
+
+  while (flag->test_and_set(std::memory_order_acquire)) {
+  }
+
+  if ((prefetch_sz > 0) && (offset >= prefetch_off) &&
+      (offset + n <= prefetch_off + prefetch_sz)) {
+    memcpy(scratch, prefetch + (offset - prefetch_off), n);
+    flag->clear(std::memory_order_release);
+    *result = Slice(scratch, n);
+
+    return Status::OK();
+  }
+
+  flag->clear(std::memory_order_release);
+#endif
+
+#if ZNS_OBJ_STORE
+  return ReadObj(offset, n, result, scratch);
+#else
+
+  if (znsfile == NULL || offset >= znsfile->size) {
+    return Status::OK();
+  }
+
+  if (offset + n > znsfile->size) {
+    n = znsfile->size - offset;
+  }
+
+  size_t cache_len = znsfile->cache_off - znsfile->wcache;
+  size_t cache_pos = znsfile->size - cache_len;
+  if (offset >= cache_pos) {
+    *result = Slice(znsfile->wcache + offset - cache_pos, n);
+    return Status::OK();
+  }
+
+  return ReadOffset(offset, n, result, scratch);
+#endif
+}
+
+Status ZNSRandomAccessFile::Prefetch(uint64_t offset, size_t n) {
+  if (ZNS_DEBUG) {
+    std::cout << __func__ << " offset: " << offset << " n: " << n << std::endl;
+  }
+
+  env_zns->filesMutex.Lock();
+  if (env_zns->files[filename_] == NULL) {
+    env_zns->filesMutex.Unlock();
+    return Status::OK();
+  }
+  env_zns->filesMutex.Unlock();
+#if ZNS_PREFETCH
+  Slice             result;
+  Status            st;
+  std::atomic_flag* flag = const_cast<std::atomic_flag*>(&prefetch_lock);
+
+  while (flag->test_and_set(std::memory_order_acquire)) {
+  }
+  if (n > ZNS_PREFETCH_BUF_SZ) {
+    n = ZNS_PREFETCH_BUF_SZ;
+  }
+
+#if ZNS_OBJ_STORE
+  st = ReadObj(offset, n, &result, prefetch);
+#else
+  st = ReadOffset(offset, n, &result, prefetch);
+#endif
+  if (!st.ok()) {
+    prefetch_sz = 0;
+    flag->clear(std::memory_order_release);
+    return Status::OK();
+  }
+
+  prefetch_sz  = n;
+  prefetch_off = offset;
+
+  flag->clear(std::memory_order_release);
+#endif /* ZNS_PREFETCH */
+
+  return Status::OK();
+}
+
+size_t ZNSRandomAccessFile::GetUniqueId(char* id, size_t max_size) const {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << std::endl;
+
+  if (max_size < (kMaxVarint64Length * 3)) {
+    return 0;
+  }
+
+  char*    rid        = id;
+  uint64_t base       = 0;
+  ZNSFile* znsFilePtr = NULL;
+
+  env_zns->filesMutex.Lock();
+  znsFilePtr = env_zns->files[filename_];
+  env_zns->filesMutex.Unlock();
+
+  if (!znsFilePtr) {
+    std::cout << "the zns random file ptr is null"
+              << "file name is " << filename_ << std::endl;
+    base = (uint64_t)this;
+  } else {
+    base = ((uint64_t)env_zns->files[filename_]->uuididx);
+  }
+
+  rid = EncodeVarint64(rid, (uint64_t)znsFilePtr);
+  rid = EncodeVarint64(rid, base);
+  assert(rid >= id);
+
+  return static_cast<size_t>(rid - id);
+}
+
+Status ZNSRandomAccessFile::InvalidateCache(size_t offset, size_t length) {
+  if (ZNS_DEBUG) {
+    std::cout << __func__ << " offset: " << offset << " length: " << length
+              << std::endl;
+  }
+
+  return Status::OK();
+}
+
+/* ### WritableFile method implementation ### */
+Status ZNSWritableFile::Append(const rocksdb::Slice&,
+                               const rocksdb::DataVerificationInfo&) {
+  return Status::OK();
+}
+
+Status ZNSWritableFile::PositionedAppend(const rocksdb::Slice&, uint64_t,
+                                         const rocksdb::DataVerificationInfo&) {
+  return Status::OK();
+}
+Status ZNSWritableFile::Append(const Slice& data) {
+  if (ZNS_DEBUG_AF)
+    std::cout << __func__ << filename_ << " size: " << data.size() << std::endl;
+
+  size_t size   = data.size();
+  size_t offset = 0;
+  Status s;
+
+  if (!znsfile->cache_off) {
+    printf("ZNSWritableFile:Append is failed.\n");
+    return Status::IOError();
+  }
+
+  size_t cpytobuf_size = ZNS_MAX_BUF;
+  if (znsfile->cache_off + data.size() > znsfile->wcache + ZNS_MAX_BUF) {
+    if (ZNS_DEBUG_AF)
+      std::cout << __func__
+                << " Maximum buffer size is "
+                   "ZNS_MAX_BUF(65536*ZNS_ALIGMENT)/(1024*1024) MB  data "
+                   "size is "
+                << data.size() << std::endl;
+
+    size = cpytobuf_size - (znsfile->cache_off - znsfile->wcache);
+    memcpy(znsfile->cache_off, data.data(), size);
+    znsfile->cache_off += size;
+    s = Sync();
+    if (!s.ok()) {
+      return Status::IOError();
+    }
+
+    offset = size;
+    size   = data.size() - size;
+
+    while (size > cpytobuf_size) {
+      memcpy(znsfile->cache_off, data.data() + offset, cpytobuf_size);
+      offset = offset + cpytobuf_size;
+      size   = size - cpytobuf_size;
+      znsfile->cache_off += cpytobuf_size;
+      s = Sync();
+      if (!s.ok()) {
+        return Status::IOError();
+      }
+    }
+  }
+
+  memcpy(znsfile->cache_off, data.data() + offset, size);
+  znsfile->cache_off += size;
+  filesize_ += data.size();
+
+  znsfile->size += data.size();
+
+  return Status::OK();
+}
+
+Status ZNSWritableFile::PositionedAppend(const Slice& data, uint64_t offset) {
+  if (ZNS_DEBUG_AF) {
+    std::cout << __func__ << __func__ << " size: " << data.size()
+              << " offset: " << offset << std::endl;
+  }
+
+  if (offset != filesize_) {
+    std::cout << "Write Violation: " << __func__ << " size: " << data.size()
+              << " offset: " << offset << std::endl;
+  }
+
+  return Append(data);
+}
+
+Status ZNSWritableFile::Truncate(uint64_t size) {
+  if (ZNS_DEBUG_AF)
+    std::cout << __func__ << filename_ << " size: " << size << std::endl;
+
+  env_zns->filesMutex.Lock();
+  if (env_zns->files[filename_] == NULL) {
+    env_zns->filesMutex.Unlock();
+    return Status::OK();
+  }
+  env_zns->filesMutex.Unlock();
+
+  size_t cache_size = (size_t)(znsfile->cache_off - znsfile->wcache);
+  size_t trun_size  = znsfile->size - size;
+
+  if (cache_size < trun_size) {
+    // TODO
+    // env_zns->filesMutex.Unlock();
+    return Status::OK();
+  }
+
+  znsfile->cache_off -= trun_size;
+  filesize_     = size;
+  znsfile->size = size;
+
+  // env_zns->filesMutex.Unlock();
+  return Status::OK();
+}
+
+Status ZNSWritableFile::Close() {
+  if (ZNS_DEBUG) {
+    std::cout << __func__ << " file: " << filename_ << std::endl;
+  }
+
+  Sync();
+  return Status::OK();
+}
+
+Status ZNSWritableFile::Flush() {
+  if (ZNS_DEBUG_AF) {
+    std::cout << __func__ << std::endl;
+  }
+
+  return Status::OK();
+}
+
+Status ZNSWritableFile::Sync() {
+  struct zrocks_map maps[2];
+  uint16_t          pieces = 0;
+  size_t            size;
+  int               ret, i;
+
+  if (!znsfile->cache_off)
+    return Status::OK();
+
+  size = (size_t)(znsfile->cache_off - znsfile->wcache);
+  if (!size)
+    return Status::OK();
+
+#if ZNS_OBJ_STORE
+  ret = zrocks_new(ztl_id, znsfile->wcache, size, level);
+#else
+  ret = zrocks_write(znsfile->wcache, size, level, maps, &pieces);
+#endif
+
+  if (ret) {
+    std::cout << __func__ << " file: " << filename_
+              << " ZRocks (write) error: " << ret << std::endl;
+    return Status::IOError();
+  }
+
+  if (ZNS_DEBUG_W) {
+    std::cout << __func__ << " file: " << filename_ << " size: " << size
+              << " level: " << level << std::endl;
+  }
+
+#if !ZNS_OBJ_STORE
+  // write page
+  env_zns->filesMutex.Lock();
+  if (env_zns->files[filename_] == NULL) {
+    env_zns->filesMutex.Unlock();
+    return Status::OK();
+  }
+  env_zns->filesMutex.Unlock();
+
+  for (i = 0; i < pieces; i++) {
+    znsfile->map.push_back(maps[i]);
+    if (ZNS_DEBUG_W) {
+      std::cout << __func__ << " file: " << filename_
+                << " DONE. node_id: " << maps[i].g.node_id
+                << " start: " << maps[i].g.start << " len: " << maps[i].g.num
+                << std::endl;
+    }
+  }
+
+  env_zns->FlushUpdateMetaData(znsfile);
+  // env_zns->filesMutex.Unlock();
+#endif
+
+  znsfile->cache_off = znsfile->wcache;
+  return Status::OK();
+}
+
+Status ZNSWritableFile::Fsync() {
+  if (ZNS_DEBUG_AF)
+    std::cout << __func__ << filename_ << std::endl;
+  return Sync();
+}
+
+Status ZNSWritableFile::InvalidateCache(size_t offset, size_t length) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << " offset: " << offset << " length: " << length
+              << std::endl;
+  return Status::OK();
+}
+
+#ifdef ROCKSDB_FALLOCATE_PRESENT
+Status ZNSWritableFile::Allocate(uint64_t offset, uint64_t len) {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << " offset: " << offset << " len: " << len
+              << std::endl;
+  return Status::OK();
+}
+#endif
+
+Status ZNSWritableFile::RangeSync(uint64_t offset, uint64_t nbytes) {
+  if (ZNS_DEBUG)
+    std::cout << "WARNING: " << __func__ << " offset: " << offset
+              << " nbytes: " << nbytes << std::endl;
+  return Status::OK();
+}
+
+size_t ZNSWritableFile::GetUniqueId(char* id, size_t max_size) const {
+  if (ZNS_DEBUG)
+    std::cout << __func__ << std::endl;
+
+  if (max_size < (kMaxVarint64Length * 3)) {
+    return 0;
+  }
+
+  char*    rid  = id;
+  uint64_t base = 0;
+  env_zns->filesMutex.Lock();
+  if (!env_zns->files[filename_]) {
+    base = (uint64_t)this;
+  } else {
+    base = ((uint64_t)znsfile->uuididx);
+  }
+  env_zns->filesMutex.Unlock();
+  rid = EncodeVarint64(rid, (uint64_t)base);
+  rid = EncodeVarint64(rid, (uint64_t)base);
+  rid = EncodeVarint64(rid, (uint64_t)base);
+  assert(rid >= id);
+
+  return static_cast<size_t>(rid - id);
+}
+
+}  // namespace rocksdb
diff --git a/file/read_write_util.cc b/file/read_write_util.cc
index 6b9379c42..425a79b1a 100644
--- a/file/read_write_util.cc
+++ b/file/read_write_util.cc
@@ -22,6 +22,20 @@ IOStatus NewWritableFile(FileSystem* fs, const std::string& fname,
   return s;
 }
 
+IOStatus NewWritableLeveledFile(Env* env,
+		       const std::string& fname,
+                       std::unique_ptr<FSWritableFile>* result,
+                       const FileOptions& options, int level) {
+
+    Status s = env->NewWritableLeveledFile(fname,
+	  reinterpret_cast<std::unique_ptr<rocksdb::WritableFile> *>(result),
+	  options, level);
+
+  TEST_KILL_RANDOM("NewWritableLeveledFile:0", rocksdb_kill_odds * REDUCE_ODDS2);
+
+  return *(reinterpret_cast<IOStatus *>(&s));
+}
+
 #ifndef NDEBUG
 bool IsFileSectorAligned(const size_t off, size_t sector_size) {
   return off % sector_size == 0;
diff --git a/file/read_write_util.h b/file/read_write_util.h
index 718135c98..7be205bf5 100644
--- a/file/read_write_util.h
+++ b/file/read_write_util.h
@@ -24,6 +24,13 @@ extern IOStatus NewWritableFile(FileSystem* fs, const std::string& fname,
                                 std::unique_ptr<FSWritableFile>* result,
                                 const FileOptions& options);
 
+// Same as NewWritableFile, but includes the level
+extern IOStatus NewWritableLeveledFile(Env *env,
+			      const std::string& fname,
+                              std::unique_ptr<FSWritableFile>* result,
+                              const FileOptions& options, int level);
+
+
 #ifndef NDEBUG
 bool IsFileSectorAligned(const size_t off, size_t sector_size);
 #endif  // NDEBUG
diff --git a/include/rocksdb/env.h b/include/rocksdb/env.h
index 16c07c7cc..aceb5e108 100644
--- a/include/rocksdb/env.h
+++ b/include/rocksdb/env.h
@@ -151,6 +151,9 @@ class Env {
     uint64_t size_bytes;
   };
 
+  // Use writable leveled file
+  bool writable_file_leveled = false;
+
   Env();
   // Construct an Env with a separate FileSystem and/or SystemClock
   // implementation
@@ -230,6 +233,19 @@ class Env {
                                  std::unique_ptr<WritableFile>* result,
                                  const EnvOptions& options) = 0;
 
+  // The same as NewWritableFile, but creates a file linked to a specific level.
+  // The implementation of this method is optional.
+  virtual Status NewWritableLeveledFile(const std::string& fname,
+                                 std::unique_ptr<WritableFile>* result,
+                                 const EnvOptions& options,
+				 int level) {
+    if (level < 0 && writable_file_leveled) {
+      return NewWritableFile (fname, result, options);
+    } else {
+      return Status::NotSupported();
+    }
+  }
+
   // Create an object that writes to a new file with the specified
   // name.  Deletes any existing file with the same name and creates a
   // new file.  On success, stores a pointer to the new file in
@@ -1715,6 +1731,9 @@ Env* NewMemEnv(Env* base_env);
 // This is a factory method for HdfsEnv declared in hdfs/env_hdfs.h
 Status NewHdfsEnv(Env** hdfs_env, const std::string& fsname);
 
+// Returns a new environment that stores its data in ZNS devices
+Status NewZNSEnv(Env** zns_env, const std::string& dev_name);
+
 // Returns a new environment that measures function call times for filesystem
 // operations, reporting results to variables in PerfContext.
 // This is a factory method for TimedEnv defined in utilities/env_timed.cc.
diff --git a/src.mk b/src.mk
index a6050fde7..8ad77a736 100644
--- a/src.mk
+++ b/src.mk
@@ -88,6 +88,8 @@ LIB_SOURCES =                                                   \
   env/fs_posix.cc                                               \
   env/file_system_tracer.cc                                     \
   env/io_posix.cc                                               \
+  env/env_zns.cc                                                \
+  env/env_zns_io.cc                                             \
   env/mock_env.cc                                               \
   file/delete_scheduler.cc                                      \
   file/file_prefetch_buffer.cc                                  \
diff --git a/tools/db_bench_tool.cc b/tools/db_bench_tool.cc
index ac5677407..c1c539bf5 100644
--- a/tools/db_bench_tool.cc
+++ b/tools/db_bench_tool.cc
@@ -18,6 +18,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
 #ifdef __APPLE__
 #include <mach/host_info.h>
 #include <mach/mach_host.h>
@@ -44,6 +46,7 @@
 #include "rocksdb/cache.h"
 #include "rocksdb/db.h"
 #include "rocksdb/env.h"
+#include "env/env_zns.h"
 #include "rocksdb/filter_policy.h"
 #include "rocksdb/memtablerep.h"
 #include "rocksdb/options.h"
@@ -1030,6 +1033,9 @@ DEFINE_string(hdfs, "",
               "Name of hdfs environment. Mutually exclusive with"
               " --env_uri and --fs_uri");
 
+DEFINE_string(zns, "", "Name of ZNS device. Mutually exclusive with"
+	      " --env_uri and hdfs.");
+
 static std::shared_ptr<ROCKSDB_NAMESPACE::Env> env_guard;
 
 static ROCKSDB_NAMESPACE::Env* FLAGS_env = ROCKSDB_NAMESPACE::Env::Default();
@@ -2872,7 +2878,38 @@ class Benchmark {
     }
   }
 
+  void test_statistics (void) {
+    size_t flush_w, compact_w, total_w;
+    FILE *fp;
+
+    if (FLAGS_statistics) {
+      flush_w = dbstats->getTickerCount(FLUSH_WRITE_BYTES);
+      compact_w = dbstats->getTickerCount(COMPACT_WRITE_BYTES);
+      total_w = flush_w + compact_w;
+
+      fprintf(stdout, "RocksDB Flush SST Writes      : %.2f MB (%lu bytes)\n",
+				    flush_w / (double) 1048576, flush_w);
+      fprintf(stdout, "RocksDB SST Compaction Writes : %.2f MB (%lu bytes)\n",
+				    compact_w / (double) 1048576, compact_w);
+      fprintf(stdout, "RocksDB Total SST Writes      : %.2f MB (%lu bytes)\n",
+				    total_w / (double) 1048576, total_w);
+
+      fp = fopen("/tmp/rocksdb_written_bytes", "w+");
+      if (fp) {
+	  fprintf(fp, "%lu", total_w);
+	  fclose(fp);
+      }
+      fp = fopen("/tmp/rocksdb_user_bytes", "w+");
+      if (fp) {
+	  fprintf(fp, "%lu", dbstats->getTickerCount(BYTES_WRITTEN));
+	  fclose(fp);
+      }
+
+    }
+  }
+
   ~Benchmark() {
+    test_statistics();
     db_.DeleteDBs();
     for (auto db : multi_dbs_) {
       db.DeleteDBs();
@@ -2882,6 +2919,9 @@ class Benchmark {
       // this will leak, but we're shutting down so nobody cares
       cache_->DisownData();
     }
+    
+    if (!FLAGS_zns.empty())
+      delete FLAGS_env;
   }
 
   Slice AllocateKey(std::unique_ptr<const char[]>* key_guard) {
@@ -7667,7 +7707,10 @@ int db_bench_tool(int argc, char** argv) {
 
   if (!FLAGS_hdfs.empty()) {
     FLAGS_env = new ROCKSDB_NAMESPACE::HdfsEnv(FLAGS_hdfs);
+  } else if (!FLAGS_zns.empty()) {
+    FLAGS_env  = new rocksdb::ZNSEnv(FLAGS_zns);
   }
+  
 
   if (!strcasecmp(FLAGS_compaction_fadvice.c_str(), "NONE"))
     FLAGS_compaction_fadvice_e = ROCKSDB_NAMESPACE::Options::NONE;
